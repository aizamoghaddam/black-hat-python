import socket
import ssl



# http
# target_host_http = 'flork.ir'
# target_port_http = 80
#
# client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# client.connect((target_host_http, target_port_http))
#
# http_request = b"GET / HTTP/1.1\r\nHost: www.flork.ir\r\n\r\n"
#
# client.send(http_request)
#
# response = client.recv(4096)
#
#
# print(response)
#
# client.close()







# https
target_host_https = 'www.tci.ir'
target_port_https = 443
context = ssl.create_default_context()

client = socket.create_connection((target_host_https, target_port_https))
client = context.wrap_socket(client, server_hostname=target_host_https)

request = "GET / HTTP/1.1\r\nHost: www.tci.ir\r\nConnection: close\r\n\r\n"
client.send(request.encode())


response = b""
while True:
    part = client.recv(4096)
    if not part:
        break
    response += part

print(response.decode("utf-8", errors="replace"))
client.close()

"""

ابتدا یک شیء سوکت با دو پارامتر `AF_INET` و `SOCK_STREAM` ایجاد می‌کنیم.
پارامتر `AF_INET` مشخص می‌کند که ما از یک آدرس IPv4 استاندارد یا یک نام میزبان (hostname)
استفاده می‌کنیم، و `SOCK_STREAM` نشان می‌دهد که این یک کلاینت TCP است.
سپس، کلاینت را به سرور متصل می‌کنیم و مقداری داده به‌صورت بایت ارسال می‌کنیم.

در مرحله آخر، منتظر می‌مانیم تا داده‌ای را از سرور دریافت کنیم، آن را چاپ کرده و سپس سوکت را می‌بندیم.
این ساده‌ترین شکل یک کلاینت TCP است، اما همان چیزی است که بیشتر اوقات خواهید نوشت.

**اما این کد چند فرض مهم درباره‌ی سوکت‌ها دارد که باید از آن‌ها آگاه باشید:**
1. فرض شده که اتصال ما همیشه موفق خواهد بود.
2. فرض شده که سرور انتظار دارد ابتدا از ما داده دریافت کند
   (برخی از سرورها ابتدا داده می‌فرستند و منتظر پاسخ می‌مانند).
3. فرض شده که سرور همیشه در زمان مناسب به ما پاسخ می‌دهد.

این فرضیات برای ساده‌تر شدن کد در نظر گرفته شده‌اند.
برنامه‌نویسان نظرات مختلفی در مورد نحوه‌ی مدیریت سوکت‌های بلاک‌شده (blocking sockets)،
مدیریت استثناها (exception handling) و مسائل مشابه دارند.
با این حال، در حوزه تست نفوذ (penetration testing)، معمولاً ابزارهای ساده و سریع
برای شناسایی یا بهره‌برداری ساخته می‌شوند و نیازی به اضافه کردن این امکانات ندارند.
بنابراین، در این فصل از توضیح این موارد صرف‌نظر شده است.

---

**توضیح کامل:**
این بخش از کتاب *Black Hat Python* درباره‌ی ایجاد یک **کلاینت TCP ساده** صحبت می‌کند.
**TCP (Transmission Control Protocol)** یکی از پروتکل‌های اصلی ارتباط در شبکه است
که بر اساس **اتصال پایدار (connection-oriented)** کار می‌کند، یعنی قبل از ارسال داده باید ابتدا ارتباط برقرار شود.

در اینجا، چندین مفهوم کلیدی وجود دارد:

1. **ایجاد سوکت:**
   - ما یک شیء **سوکت (socket)** با `AF_INET` و `SOCK_STREAM` می‌سازیم.
   - `AF_INET` مشخص می‌کند که از **IPv4** استفاده می‌کنیم.
   - `SOCK_STREAM` نشان می‌دهد که این **یک ارتباط TCP** است
     (برخلاف `SOCK_DGRAM` که برای UDP است).

2. **اتصال به سرور:**
   - کلاینت تلاش می‌کند به سرور متصل شود.
   - اگر سرور در حال اجرا باشد و پورت مورد نظر باز باشد، اتصال برقرار می‌شود.

3. **ارسال داده:**
   - داده‌ها باید به‌صورت **بایت (bytes)** ارسال شوند،
     چون سوکت‌ها فقط با داده‌های باینری کار می‌کنند.

4. **دریافت پاسخ:**
   - پس از ارسال داده، کلاینت منتظر دریافت داده از سرور می‌ماند.
   - اینجا فرض شده که سرور همیشه پاسخی می‌فرستد.

5. **بستن ارتباط:**
   - در نهایت، بعد از دریافت پاسخ، سوکت بسته می‌شود.

**چند فرض نادرست که در این کد وجود دارد:**
- **اتصال همیشه موفق خواهد بود:** در واقع ممکن است سرور خاموش باشد،
  فایروال ارتباط را مسدود کند یا آدرس اشتباه باشد.
- **سرور همیشه انتظار دارد که کلاینت ابتدا پیام ارسال کند:** بعضی سرورها خودشان ابتدا پیام می‌فرستند.
- **سرور همیشه پاسخ را به‌موقع می‌فرستد:** ممکن است سرور کند باشد یا اصلاً پاسخی ارسال نکند.

در دنیای واقعی، برنامه‌نویسان معمولاً این مشکلات را با **مدیریت استثناها (exception handling)**
و تنظیم **timeout (محدودیت زمانی)** حل می‌کنند.
اما در دنیای **تست نفوذ (Pentesting)**، ابزارهای سریع و موقتی ساخته می‌شوند که این پیچیدگی‌ها را در نظر نمی‌گیرند.

---


ابتدا یک شیء سوکت با دو پارامتر `AF_INET` و `SOCK_STREAM` ایجاد می‌کنیم.
پارامتر `AF_INET` نشان می‌دهد که از یک آدرس استاندارد IPv4 یا یک نام میزبان استفاده می‌شود،
و `SOCK_STREAM` مشخص می‌کند که این یک کلاینت TCP است.
سپس، کلاینت را به سرور متصل کرده و مقداری داده را به‌صورت بایت ارسال می‌کنیم.

در گام بعدی، منتظر دریافت داده از سمت سرور می‌مانیم،
پاسخ را چاپ کرده و سپس اتصال را می‌بندیم.
این ساده‌ترین فرم یک کلاینت TCP است و اغلب مواقع از همین روش استفاده خواهد شد.

**فرضیات این کد:**
1. اتصال به سرور همیشه موفق خواهد بود.
2. سرور انتظار دارد ابتدا از ما داده دریافت کند.
3. سرور همیشه پاسخ را به‌موقع ارسال می‌کند.

این فرضیات برای ساده‌سازی کد در نظر گرفته شده‌اند.
در دنیای واقعی، برای مدیریت این مشکلات، برنامه‌نویسان معمولاً
از روش‌هایی مانند **مدیریت استثناها، بررسی وضعیت سرور، و تنظیم زمان انتظار (timeout)** استفاده می‌کنند.
اما در حوزه **تست نفوذ (penetration testing)**، ابزارها بیشتر به‌صورت سریع و بدون این جزئیات نوشته می‌شوند،
بنابراین این بخش‌ها در این فصل نادیده گرفته شده‌اند.


"""